import React, { useEffect, useRef, useState } from "react";

// ===== Guitar 6-String Tab Editor (v3, rewritten single file) =====
// è¦ä»¶:
// - ãƒ¢ãƒ¼ãƒ‰: é¸æŠ(Select) / æç”»(Draw)
// - æç”»ãƒ¢ãƒ¼ãƒ‰: ç›´è¿‘ã«æŠ¼ã—ãŸæ•°å­—(0-24ã®é€£çµå…¥åŠ›å¯¾å¿œ) or x(ãƒŸãƒ¥ãƒ¼ãƒˆ) ã‚’é…ç½®ã€‚æœªè¨­å®šã¯ 0ã€‚
// - ã‚¯ãƒªãƒƒã‚¯=é…ç½®ã€ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯=ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ç·¨é›†ï¼ˆæ•°å­—ã®ã¿ / Ã— ã¯ç·¨é›†ä¸å¯ï¼‰
// - ç·¨é›†æ ã¯å¤–ã‚¯ãƒªãƒƒã‚¯/ãƒ„ãƒ¼ãƒ«ãƒãƒ¼æ“ä½œã§ã‚‚ç¢ºå®šã—ã€é¸æŠè§£é™¤
// - é¸æŠãƒ¢ãƒ¼ãƒ‰: å˜ä½“é¸æŠ + çŸ©å½¢ç¯„å›²é¸æŠã€çŸ¢å°ã‚­ãƒ¼ã§ç§»å‹•ï¼ˆã“ã®ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿ï¼‰
// - ç§»å‹•/é…ç½®ã®ä¸Šæ›¸ã: æ—¢å­˜ãŒã‚ã‚Œã°ä¸Šæ›¸ã
// - å¼¦æ–¹å‘ã¯ã¿å‡ºã—ã¯å‰Šé™¤ï¼ˆ0..5ä»¥å¤–ã¯æ¨ã¦ã‚‹ï¼‰
// - ã‚¯ãƒªãƒƒã‚¯ä½ç½®è£œæ­£ï¼ˆpagePadding + leftPaddingï¼‰ã‚’ç¶­æŒ

// ===== å‹ =====

type Tuning = number[]; // MIDIï¼ˆè¡¨ç¤ºã¯æ–‡å­—ï¼‰

type NoteKind = "fret" | "mute"; // mute ã¯ Ã—

type TabItem = {
  id: string;
  rowIndex: number; // ã©ã®è¡Œã‹
  bar: number;
  tick: number;
  stringIndex: number; // 0..5ï¼ˆ0=1å¼¦ï¼‰
  kind: NoteKind;
  fret?: number; // kind=fret ã®ã¨ã 0..24
};

type HistoryState = {
  items: TabItem[];
  bars: number;
  beatsPerBar: number;
  division: number;
  perSystemBars: number;
};

// ===== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====

const defaultTuning: Tuning = [64, 59, 55, 50, 45, 40]; // E4 B3 G3 D3 A2 E2
const tuningNames = ["E4", "B3", "G3", "D3", "A2", "E2"]; // è¡¨ç¤ºç”¨
const uid = () => Math.random().toString(36).slice(2, 10);
const clamp = (n: number, a: number, b: number) => Math.max(a, Math.min(b, n));

// å®‰å…¨ãª clientåº§æ¨™ -> SVG(viewBox)åº§æ¨™ å¤‰æ›ï¼ˆ0å¹…/0é«˜ãƒ»NaNãƒ»CTMãªã—ã‚’å¸åï¼‰
const clientToSvg = (svg: SVGSVGElement, clientX: number, clientY: number) => {
  const r = svg.getBoundingClientRect();
  const vb = svg.viewBox?.baseVal;
  const safeW = r.width || 1;   // 0é™¤ç®—å›é¿
  const safeH = r.height || 1;
  let x = (clientX - r.left) * ((vb?.width  || svg.width.baseVal.value  || 1) / safeW);
  let y = (clientY - r.top)  * ((vb?.height || svg.height.baseVal.value || 1) / safeH);

  if (!Number.isFinite(x) || !Number.isFinite(y)) {
    const pt = svg.createSVGPoint();
    pt.x = clientX; pt.y = clientY;
    const ctm = svg.getScreenCTM();
    if (ctm) {
      const loc = pt.matrixTransform(ctm.inverse());
      x = loc.x; y = loc.y;
    } else {
      x = 0; y = 0;
    }
  }
  return { x, y };
};

// ==== éŸ³åãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ====
const noteNames = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];

const midiToName = (midi: number) => {
  const name = noteNames[midi % 12];
  const octave = Math.floor(midi / 12) - 1; // MIDIè¦æ ¼: 60=C4
  return `${name}${octave}`;
};

// ===== ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ =====

export default function App() {
  // æ¥½è­œãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
  const [bars, setBars] = useState(8);
  const [beatsPerBar, setBeatsPerBar] = useState(4);
  const [division, setDivision] = useState(4); // 1æ‹ã‚ãŸã‚Šã®ã‚°ãƒªãƒƒãƒ‰æ•°ï¼ˆ4 = 16åˆ†ï¼‰
  const [perSystemBars, setPerSystemBars] = useState(4); // 1æ®µã®å°ç¯€æ•°ï¼ˆè¡¨ç¤ºã«ã®ã¿ä½¿ç”¨ï¼‰
  const [tuning] = useState<Tuning>(defaultTuning);

  // ãƒãƒ¼ãƒˆï¼ˆã‚¢ã‚¤ãƒ†ãƒ ï¼‰
  const [items, setItems] = useState<TabItem[]>([]);

  // è­œé¢ã®è¡Œ
  const [rowCount, setRowCount] = useState(1);

  // æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã®åŒæœŸï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆONï¼‰
  const [linkScroll, setLinkScroll] = useState(true);

  // ä½¿ã£ã¦ã„ãªã„ãŒæ®‹ã™ï¼šå°†æ¥çš„ãªãƒ‰ãƒ©ãƒƒã‚°æ¤œå‡ºã®äºˆå‚™
  const dragDetectRef = useRef<{
    arming: boolean;
    startClientX: number;
    startClientY: number;
    item?: TabItem;
  } | null>(null);

  // å„è¡Œã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«è¦ç´ å‚ç…§
  const scrollRefs = useRef<HTMLDivElement[]>([]);
  scrollRefs.current = Array.from({ length: rowCount }, (_, i) => scrollRefs.current[i] || null) as any;

  // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åŒæœŸä¸­ã®ãƒ«ãƒ¼ãƒ—æŠ‘æ­¢ãƒ•ãƒ©ã‚°
  const isSyncingScrollRef = useRef(false);

  // ãƒ¢ãƒ¼ãƒ‰
  type Mode = "select" | "draw";
  const [mode, setMode] = useState<Mode>("draw");

  // æç”»ãƒ¢ãƒ¼ãƒ‰ã®ç›´è¿‘ã‚­ãƒ¼
  const [drawToken, setDrawToken] = useState<{ kind: NoteKind; value?: number } | null>(null);

  // é¸æŠ
  const [selectedIds, setSelectedIds] = useState<string[]>([]);
  const isSelected = (id: string) => selectedIds.includes(id);

  // çŸ©å½¢é¸æŠ
  const [marquee, setMarquee] = useState<null | { x0: number; y0: number; x1: number; y1: number }>(null);
  const [draggingMarquee, setDraggingMarquee] = useState(false);

  // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ç·¨é›†
  const [editingId, setEditingId] = useState<string | null>(null);
  const [editValue, setEditValue] = useState<string>("");

  // Undo/Redo
  const [undoStack, setUndoStack] = useState<HistoryState[]>([]);
  const [redoStack, setRedoStack] = useState<HistoryState[]>([]);

  const pushHistory = () => {
    setUndoStack((st) => [
      ...st,
      { items: structuredClone(items), bars, beatsPerBar, division, perSystemBars },
    ]);
    setRedoStack([]);
  };

  const undo = () => {
    const prev = undoStack[undoStack.length - 1];
    if (!prev) return;
    setRedoStack((r) => [
      { items: structuredClone(items), bars, beatsPerBar, division, perSystemBars },
      ...r,
    ]);
    setUndoStack((st) => st.slice(0, -1));
    setItems(prev.items);
    setBars(prev.bars);
    setBeatsPerBar(prev.beatsPerBar);
    setDivision(prev.division);
    setPerSystemBars(prev.perSystemBars);
    setSelectedIds([]);
    setEditingId(null);
  };

  const redo = () => {
    const nxt = redoStack[0];
    if (!nxt) return;
    setUndoStack((st) => [
      ...st,
      { items: structuredClone(items), bars, beatsPerBar, division, perSystemBars },
    ]);
    setRedoStack((r) => r.slice(1));
    setItems(nxt.items);
    setBars(nxt.bars);
    setBeatsPerBar(nxt.beatsPerBar);
    setDivision(nxt.division);
    setPerSystemBars(nxt.perSystemBars);
    setEditingId(null);
  };

  // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆpxï¼‰
  const zoom = 1;
  const pagePadding = 0;
  const leftPadding = 0; // å·¦ãƒãƒ¼ã‚¸ãƒ³ã‚’ã‚¼ãƒ­ã«ã—ã¦ãƒ©ãƒ™ãƒ«å³ç«¯ã«å¯†ç€
  const rightPadding = 24 * zoom;
  const topPadding = 20 * zoom;
  const bottomPadding = 24 * zoom;
  const stringGap = 22 * zoom;
  const stringCount = 6;

  const ticksPerBar = beatsPerBar * division;

  // æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åŸºæº–ï¼š1å°ç¯€ã®ãƒ”ã‚¯ã‚»ãƒ«å¹…ï¼ˆå¥½ã¿ã§èª¿æ•´ï¼‰
  const barPx = 160 * zoom;
  const pxPerTick = barPx / (ticksPerBar || 1);

  // 1è¡Œã®SVGã‚µã‚¤ã‚ºï¼ˆæ¨ªã«é•·ã„ï¼‰
  const rowSvgWidth  = pagePadding * 2 + leftPadding + bars * barPx + rightPadding;
  const rowSvgHeight = pagePadding * 2 + (stringCount - 1) * stringGap + topPadding + bottomPadding;

  // è¡¨ç¤ºã‚ªãƒ—ã‚·ãƒ§ãƒ³
  const [showSubdivision, setShowSubdivision] = useState(true);
  const [showBeat, setShowBeat] = useState(true);
  const [showBarNumber, setShowBarNumber] = useState(true);

  // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼
  const [exportOpen, setExportOpen] = useState(false);
  const exportMenuRef = useRef<HTMLDivElement | null>(null);

  // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ãƒ•ãƒ©ã‚°ï¼ˆã‚«ãƒ¼ã‚½ãƒ«å¼·åˆ¶ç”¨ï¼‰
  const [isDragging, setIsDragging] = useState(false);

  const dragRef = useRef<{
    active: boolean;
    pointerId: number | null;
    rowIndex: number;
    startCursorBar: number;
    startCursorTick: number;
    startCursorString: number;
    captureEl?: SVGSVGElement;
    captureTarget?: Element;
    startBar: number;
    startTick: number;
    startString: number;
    dxTick: number;
    dyString: number;
  } | null>(null);

  const svgRefs = useRef<(SVGSVGElement | null)[]>([]);
  const getRowSvg = (rowIndex: number) => svgRefs.current[rowIndex] ?? null;
  // ç·¨é›†é–‹å§‹ç›´å¾Œã®èª¤ blur/å¤–ã‚¯ãƒªãƒƒã‚¯ç„¡è¦–
  const justBeganEditRef = useRef(false);
  // æ•°å­—ã‚­ãƒ¼ã®é€£çµå…¥åŠ›ï¼ˆ1ç§’ä»¥å†…ï¼‰
  const digitComposeRef = useRef<{ value: number; time: number } | null>(null);

  // æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç‰ˆ: å…¨ä½“ã®çµ¶å¯¾tickã‚’ãã®ã¾ã¾Xã«
  const xOf = (bar: number, tick: number) => {
    const absTicks = bar * ticksPerBar + tick;
    return leftPadding + absTicks * pxPerTick;
  };

  const quantizeX = (x: number) => {
    if (!Number.isFinite(x)) x = pagePadding + leftPadding; // éFiniteãªã‚‰å·¦ç«¯ã¸ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
    const leftEdge  = pagePadding + leftPadding;
    const rightEdge = pagePadding + leftPadding + bars * barPx;
    const clampedX  = clamp(x, leftEdge, rightEdge);
    const tickFloat = (clampedX - leftEdge) / (pxPerTick || 1);
    const tpb = (ticksPerBar || 1);
    const bar = clamp(Math.floor(tickFloat / tpb), 0, bars - 1);
    const tickInBar = clamp(Math.round(tickFloat - bar * tpb), 0, tpb - 1);
    return { bar, tick: tickInBar };
  };

  const yForString = (stringIndex: number) => {
    const y0 = pagePadding + topPadding;
    return y0 + stringIndex * stringGap;
  };

  // ==== å…¥åŠ›ã¨ç·¨é›†ï¼ˆåº§æ¨™â†’è­œé¢ä½ç½®ï¼‰ ====
  const [hoverPos, setHoverPos] = useState<{ bar: number; tick: number; stringIndex: number } | null>(null);

  const cancelEditingAndSelection = () => {
    if (justBeganEditRef.current) return;
    if (editingId) commitInlineEdit();
    setSelectedIds([]);
  };

  const placeAtRow = (rowIndex: number, pos: { bar: number; tick: number; stringIndex: number }) => {
    const token = drawToken || { kind: "fret" as NoteKind, value: 0 };
    const newItem: TabItem = token.kind === "mute"
      ? { id: uid(), rowIndex, bar: pos.bar, tick: pos.tick, stringIndex: pos.stringIndex, kind: "mute" }
      : { id: uid(), rowIndex, bar: pos.bar, tick: pos.tick, stringIndex: pos.stringIndex, kind: "fret", fret: clamp(token.value ?? 0, 0, 24) };
    pushHistory();
    setItems((arr) => {
      const noOld = arr.filter(i => !(i.rowIndex === rowIndex && i.bar === pos.bar && i.tick === pos.tick && i.stringIndex === pos.stringIndex));
      return [...noOld, newItem];
    });
  };

  // ==== ãƒ‰ãƒ©ãƒƒã‚°æ™‚ã®ã‚«ãƒ¼ã‚½ãƒ«å›ºå®šï¼ˆbody/htmlã«ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹ï¼‰ ====
  useEffect(() => {
    const html = document.documentElement;
    const body = document.body;
    if (isDragging) {
      html.setAttribute("data-dragging", "1");
      body.style.cursor = "grabbing";
    } else {
      html.removeAttribute("data-dragging");
      body.style.cursor = "";
    }
    return () => {
      html.removeAttribute("data-dragging");
      body.style.cursor = "";
    };
  }, [isDragging]);

  // === ã‚°ãƒ­ãƒ¼ãƒãƒ« DnD ===
  const onGlobalPointerMove = (ev: PointerEvent) => {
    const dr = dragRef.current;
    if (!dr || !dr.active) return;

    const svg = dr.captureEl ?? getRowSvg(dr.rowIndex);
    if (!svg) return;

    const loc = clientToSvg(svg, ev.clientX, ev.clientY);

    // ç¾åœ¨ã‚«ãƒ¼ã‚½ãƒ«ã®ã‚°ãƒªãƒƒãƒ‰ã‚’é‡å­åŒ–
    const y0 = pagePadding + topPadding;
    const yAdj = clamp(
      loc.y,
      y0 - stringGap / 2,
      y0 + (stringCount - 1) * stringGap + stringGap / 2
    );
    const curString = clamp(Math.round((yAdj - y0) / stringGap), 0, stringCount - 1);

    const { bar: curBar, tick: curTick } = quantizeX(loc.x);

    // å·®åˆ†ã¯ã€Œç¾åœ¨ã‚«ãƒ¼ã‚½ãƒ« âˆ’ é–‹å§‹ã‚«ãƒ¼ã‚½ãƒ«ã€
    const startCursorAbs = dr.startCursorBar * (ticksPerBar || 1) + dr.startCursorTick;
    const curAbs         = curBar * (ticksPerBar || 1) + curTick;

    dragRef.current = {
      ...dr,
      dxTick:   curAbs - startCursorAbs,
      dyString: curString - dr.startCursorString,
    };
  };

  const cleanupDragSideEffects = () => {
    const dr = dragRef.current;
    if (dr?.captureEl) {
      try { dr.captureEl.classList.remove("dragging"); } catch {}
    }
    setIsDragging(false);
    document.removeEventListener("pointermove", onGlobalPointerMove);
    document.removeEventListener("pointerup", onGlobalPointerUp);
  };

  const onGlobalPointerUp = (ev: PointerEvent) => {
    const dr = dragRef.current;
    if (!dr || !dr.active) { cleanupDragSideEffects(); return; }

    const dx = dr.dxTick | 0;
    const dy = dr.dyString | 0;
    if (dx !== 0 || dy !== 0) {
      moveSelection(dx, dy);
    }

    // pointer capture ã‚’å®‰å…¨ã«è§£æ”¾
    if (dr.pointerId != null && dr.captureTarget) {
      try {
        const tgt = dr.captureTarget as any;
        if (typeof tgt.hasPointerCapture === "function") {
          if (tgt.hasPointerCapture(dr.pointerId)) {
            tgt.releasePointerCapture(dr.pointerId);
          }
        } else {
          tgt.releasePointerCapture?.(dr.pointerId);
        }
      } catch {}
    }

    cleanupDragSideEffects();
    dragRef.current = null;
    ev.preventDefault?.();
  };

  const beginDragFromItem = (
    e: React.PointerEvent<SVGGElement>,
    it: TabItem,
    rowIndex: number
  ) => {
    if (mode !== "select" || editingId) return;

    setSelectedIds(prev => (prev.includes(it.id) ? prev : [it.id]));
    setDraggingMarquee(false);
    setMarquee(null);

    const pid = (e as any).pointerId ?? (e.nativeEvent as any)?.pointerId ?? null;
    const svgEl = getRowSvg(rowIndex) ?? (e.currentTarget as SVGGElement).ownerSVGElement ?? null;

    let startCursorBar = it.bar, startCursorTick = it.tick, startCursorString = it.stringIndex;
    if (svgEl) {
      const loc = clientToSvg(svgEl, (e.nativeEvent as any).clientX ?? 0, (e.nativeEvent as any).clientY ?? 0);
      const y0 = pagePadding + topPadding;
      const yAdj = clamp(loc.y, y0 - stringGap / 2, y0 + (stringCount - 1) * stringGap + stringGap / 2);
      startCursorString = clamp(Math.round((yAdj - y0) / stringGap), 0, stringCount - 1);
      const qt = quantizeX(loc.x);
      startCursorBar = qt.bar;
      startCursorTick = qt.tick;
    }

    if (pid != null) { try { (e.currentTarget as SVGGElement).setPointerCapture(pid); } catch {} }

    dragRef.current = {
      active: true,
      pointerId: pid,
      rowIndex,
      captureEl: svgEl || undefined,
      captureTarget: e.currentTarget as Element,
      startBar: it.bar,
      startTick: it.tick,
      startString: it.stringIndex,
      startCursorBar,
      startCursorTick,
      startCursorString,
      dxTick: 0,
      dyString: 0,
    };

    if (svgEl) {
      try { svgEl.classList.add("dragging"); } catch {}
    }
    setIsDragging(true);

    document.addEventListener("pointermove", onGlobalPointerMove, { passive: true });
    document.addEventListener("pointerup", onGlobalPointerUp);
    e.stopPropagation();
    e.preventDefault();
  };

  const normRect = (m: { x0: number; y0: number; x1: number; y1: number }) => {
    const x = Math.min(m.x0, m.x1);
    const y = Math.min(m.y0, m.y1);
    return { x, y, w: Math.abs(m.x1 - m.x0), h: Math.abs(m.y1 - m.y0) };
  };

  // é¸æŠç§»å‹•
  const moveSelection = (dxTick: number, dyString: number) => {
    if (mode !== "select") return;
    if (selectedIds.length === 0) return;

    pushHistory();
    setItems((arr) => {
      const sel = arr.filter((i) => selectedIds.includes(i.id));
      const rest = arr.filter((i) => !selectedIds.includes(i.id));

      const moved: TabItem[] = [];
      for (const it of sel) {
        let bar = it.bar;
        let tick = it.tick + dxTick;
        let stringIndex = it.stringIndex + dyString;

        // å°ç¯€ã¾ãŸã
        while (tick < 0) { bar = Math.max(0, bar - 1); tick += (ticksPerBar || 1); }
        while (tick >= (ticksPerBar || 1)) { tick -= (ticksPerBar || 1); bar = Math.min(bars - 1, bar + 1); }

        // å¼¦ã¯ã¿å‡ºã—â†’ç ´æ£„
        if (stringIndex < 0 || stringIndex > 5) continue;
        moved.push({ ...it, bar, tick, stringIndex });
      }

      // ä¸Šæ›¸ã
      let next = [...rest];
      for (const it of moved) {
        next = next.filter((x) => !(x.bar === it.bar && x.tick === it.tick && x.stringIndex === it.stringIndex && x.rowIndex === it.rowIndex));
        next.push(it);
      }
      return next;
    });
  };

  const canReset = items.length > 0;
  const canUndo  = undoStack.length > 0;
  const canRedo  = redoStack.length > 0;

  // ==== æç”»ãƒ¢ãƒ¼ãƒ‰ã®ãƒ”ãƒƒãƒè¡¨ç¤ºç”¨ãƒ†ã‚­ã‚¹ãƒˆ ====
  const pitchText: string | null = (() => {
    if (mode !== "draw") return null;
    if (drawToken?.kind === "mute") return "mute";
    const fret = clamp(drawToken?.value ?? 0, 0, 24);
    if (!hoverPos) return "â€”";
    const base = tuning[hoverPos.stringIndex];
    const midi = base + fret;
    return midiToName(midi);
  })();

  // DnD ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
  const computeDragPreview = (): TabItem[] => {
    const dr = dragRef.current;
    if (!dr || !dr.active) return [];
    const { dxTick, dyString } = dr;
    if (dxTick === 0 && dyString === 0) return [];

    const sel = items.filter((i) => selectedIds.includes(i.id));
    const preview: TabItem[] = [];

    for (const it of sel) {
      let bar = it.bar;
      let tick = it.tick + dxTick;
      let stringIndex = it.stringIndex + dyString;

      while (tick < 0) { bar = Math.max(0, bar - 1); tick += (ticksPerBar || 1); }
      while (tick >= (ticksPerBar || 1)) { tick -= (ticksPerBar || 1); bar = Math.min(bars - 1, bar + 1); }
      if (stringIndex < 0 || stringIndex > 5) continue;
      preview.push({ ...it, bar, tick, stringIndex });
    }
    return preview;
  };

  const beginInlineEdit = (id: string) => {
    const n = items.find((x) => x.id === id); if (!n) return;
    if (n.kind === "mute") return; // Ã—ã¯ç·¨é›†ã—ãªã„
    setSelectedIds([id]);
    setEditingId(id);
    setEditValue(String(n.fret ?? 0));
    justBeganEditRef.current = true;
    setTimeout(() => { justBeganEditRef.current = false; }, 50);
  };

  const commitInlineEdit = () => {
    if (!editingId) return;
    const v0 = parseInt(editValue || "0", 10);
    const v = clamp(Number.isFinite(v0) ? v0 : 0, 0, 24);
    setItems((arr) => arr.map((n) => (n.id === editingId ? { ...n, kind: "fret", fret: v } : n)));
    setEditingId(null);
    setSelectedIds([]);
  };

  // ==== ã‚­ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼ˆwindowã¸é›†ç´„ï¼‰ ====
  useEffect(() => {
    const isEditableEl = (el: Element | null) => {
      if (!el) return false;
      const he = el as HTMLElement;
      const tag = he.tagName.toLowerCase();
      if (tag === "input" || tag === "textarea") return true;
      if (he.isContentEditable) return true;
      return false;
    };

    const onKey = (e: KeyboardEvent) => {
      if (e.isComposing) return;
      if (editingId) return;
      if (isEditableEl(document.activeElement)) return;

      // Undo/Redo
      if ((e.metaKey || e.ctrlKey) && (e.key === "z" || e.key === "Z")) {
        e.preventDefault();
        e.shiftKey ? redo() : undo();
        return;
      }
      if ((e.metaKey || e.ctrlKey) && (e.key === "y" || e.key === "Y")) {
        e.preventDefault();
        redo();
        return;
      }

      if (mode === "draw") {
        if (/^[0-9]$/.test(e.key)) {
          const d = Number(e.key);
          const now = Date.now();
          const buf = digitComposeRef.current;
          let newVal: number;
          if (buf && now - buf.time <= 1000) {
            const cand = buf.value * 10 + d;
            newVal = cand <= 24 ? cand : d;
          } else {
            newVal = d;
          }
          digitComposeRef.current = { value: newVal, time: now };
          setDrawToken({ kind: "fret", value: newVal });
          e.preventDefault();
          return;
        }
        if (e.key === "x" || e.key === "X") {
          digitComposeRef.current = null;
          setDrawToken({ kind: "mute" });
          e.preventDefault();
          return;
        }
        return;
      }

      if (mode === "select") {
        if (e.key === "ArrowLeft")  { e.preventDefault(); moveSelection(-1, 0); return; }
        if (e.key === "ArrowRight") { e.preventDefault(); moveSelection(1, 0);  return; }
        if (e.key === "ArrowUp")    { e.preventDefault(); moveSelection(0, -1); return; }
        if (e.key === "ArrowDown")  { e.preventDefault(); moveSelection(0, 1);  return; }
        if (e.key === "Delete" || e.key === "Backspace") {
          e.preventDefault();
          if (selectedIds.length) {
            pushHistory();
            setItems(arr => arr.filter(i => !selectedIds.includes(i.id)));
            setSelectedIds([]);
          }
          return;
        }
      }
    };

    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [mode, editingId, selectedIds, items, bars, beatsPerBar, division, perSystemBars]);

  // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼šå¤–å´ã‚¯ãƒªãƒƒã‚¯ / Esc ã§é–‰ã˜ã‚‹
  useEffect(() => {
    const onDocClick = (e: MouseEvent) => {
      if (exportMenuRef.current && !exportMenuRef.current.contains(e.target as Node)) {
        setExportOpen(false);
      }
    };
    const onEsc = (e: KeyboardEvent) => {
      if (e.key === "Escape") setExportOpen(false);
    };
    document.addEventListener("mousedown", onDocClick);
    document.addEventListener("keydown", onEsc);
    return () => {
      document.removeEventListener("mousedown", onDocClick);
      document.removeEventListener("keydown", onEsc);
    };
  }, []);

  // ==== å‡ºåŠ› ====
  const getActiveRowSvg = (): SVGSVGElement | null => {
    return svgRefs.current[0] ?? (document.querySelector("svg.row-svg") as SVGSVGElement | null);
  };

  const svgToBlob = () => {
    const svgEl = getActiveRowSvg();
    if (!svgEl) return null;
    const serializer = new XMLSerializer();
    const source = serializer.serializeToString(svgEl);
    return new Blob([source], { type: "image/svg+xml;charset=utf-8" });
  };

  const downloadSVG = () => {
    const blob = svgToBlob(); if (!blob) return;
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = "tab.svg"; a.click();
    URL.revokeObjectURL(url);
  };

  const downloadPNG = async () => {
    const blob = svgToBlob(); if (!blob) return;
    const url = URL.createObjectURL(blob);
    const img = new Image(); img.src = url; await img.decode();
    const canvas = document.createElement("canvas");
    canvas.width = Math.ceil(rowSvgWidth); canvas.height = Math.ceil(rowSvgHeight);
    const ctx = canvas.getContext("2d"); if (!ctx) return;
    ctx.fillStyle = "white"; ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0);
    const png = canvas.toDataURL("image/png");
    const a = document.createElement("a"); a.href = png; a.download = "tab.png"; a.click();
    URL.revokeObjectURL(url);
  };

  // ==== ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°è£œåŠ© ====
  const drawText = (x: number, y: number, t: string, color = "#111", bold = true) => (
    <text x={x} y={y} dominantBaseline="middle" textAnchor="middle" fontFamily="ui-monospace, Menlo, monospace" fontSize={13} fontWeight={bold ? 700 : 600} fill={color}>{t}</text>
  );

  const itemXYRow = (n: TabItem) => {
    const x = pagePadding + xOf(n.bar, n.tick);
    const y = yForString(n.stringIndex);
    return { x, y };
  };

  const hitTestItemAtX = (rowIndex: number, x: number, y: number) => {
    for (const it of items) {
      if (it.rowIndex !== rowIndex) continue;
      const { x: ix, y: iy } = itemXYRow(it);
      if (Math.abs(ix - x) <= 12 && Math.abs(iy - y) <= 12) return it;
    }
    return null;
  };

  // ä¸€è¡Œã®æç”»
  const renderRow = (rowIndex: number) => {
    // å·¦å›ºå®šã‚«ãƒ©ãƒ ï¼ˆå¼¦åï¼‰
    const LeftFixed = () => (
      <div className="row-left-fixed">
        {[...Array(6)].map((_, s) => (
          <div key={s} className="row-left-line" style={{ top: yForString(s) }}>
            <span className="row-left-name">{tuningNames[s]}</span>
          </div>
        ))}
      </div>
    );

    // å³ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« + SVG
    const RightScroll = () => (
      <div
        className="row-right-scroll"
        ref={(el) => { if (el) scrollRefs.current[rowIndex] = el; }}
        onScroll={(ev) => {
          if (!linkScroll) return;
          if (isSyncingScrollRef.current) return;
          const src = ev.currentTarget;
          isSyncingScrollRef.current = true;
          scrollRefs.current.forEach((el, i) => {
            if (!el || i === rowIndex) return;
            el.scrollLeft = src.scrollLeft;
          });
          isSyncingScrollRef.current = false;
        }}
      >
      <svg
        ref={(el) => { svgRefs.current[rowIndex] = el; }}
        width={rowSvgWidth}
        height={rowSvgHeight}
        viewBox={`0 0 ${rowSvgWidth} ${rowSvgHeight}`}
        onPointerMove={(e) => {
          const svg = svgRefs.current[rowIndex] ?? (e.currentTarget as SVGSVGElement);
          if (!svg) return;
          const loc = clientToSvg(svg, e.clientX, e.clientY);

          const y0 = pagePadding + topPadding;
          const y = clamp(loc.y, y0 - stringGap / 2, y0 + (stringCount - 1) * stringGap + stringGap / 2);
          const stringIndex = clamp(Math.round((y - y0) / stringGap), 0, stringCount - 1);

          const { bar, tick } = quantizeX(loc.x);
          setHoverPos({ bar, tick, stringIndex });

          if (draggingMarquee) {
            setMarquee((m) => (m ? { ...m, x1: loc.x, y1: loc.y } : m));
          }
        }}

          onPointerLeave={() => setHoverPos(null)}
          onPointerDown={(e) => {
            const svg = e.currentTarget as SVGSVGElement;
            const loc = clientToSvg(svg, e.clientX, e.clientY);

            // æ—¢å­˜ãƒãƒ¼ãƒˆã®ãƒ’ãƒƒãƒˆ
            const hit = hitTestItemAtX(rowIndex, loc.x, loc.y);
            const isBackground = !hit;

            if (isBackground) cancelEditingAndSelection();

            if (mode === "select") {
              if (isBackground) {
                setMarquee({ x0: loc.x, y0: loc.y, x1: loc.x, y1: loc.y });
                setDraggingMarquee(true);
              } else {
                beginDragFromItem(e as any, hit!, rowIndex);
              }
              return;
            }

            if (mode === "draw") {
              const y0 = pagePadding + topPadding;
              const y = clamp(
                loc.y,
                y0 - stringGap / 2,
                y0 + (stringCount - 1) * stringGap + stringGap / 2
              );
              const stringIndex = clamp(Math.round((y - y0) / stringGap), 0, stringCount - 1);
              const { bar, tick } = quantizeX(loc.x);

              placeAtRow(rowIndex, { bar, tick, stringIndex });

              e.stopPropagation();
              e.preventDefault();
              return;
            }
          }}
          onPointerUp={() => {
            if (draggingMarquee && marquee) {
              const rect = normRect(marquee);
              const ids = items
                .filter((it) => it.rowIndex === rowIndex)
                .filter((it) => {
                  const { x, y } = itemXYRow(it);
                  return x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h;
                })
                .map((it) => it.id);
              setSelectedIds(ids);
            }
            setDraggingMarquee(false);
            setMarquee(null);
          }}
          className="row-svg"
        >
          {/* èƒŒæ™¯ */}
          <rect x={0} y={0} width={rowSvgWidth} height={rowSvgHeight} fill="white" />

          {/* ç¸¦ã‚°ãƒªãƒƒãƒ‰ï¼ˆå°ç¯€å¢ƒç•Œ/æ‹/ç´°åˆ†ï¼‰ */}
          {[...Array(bars)].map((_, bar) => {
            const barX = pagePadding + xOf(bar, 0);
            return (
              <g key={`bar-${bar}`}>
                {/* å°ç¯€ç·š */}
                <line x1={barX} x2={barX} y1={pagePadding + topPadding - 14} y2={pagePadding + topPadding + (stringCount - 1) * stringGap + 14}
                      stroke="#adb5bd" strokeWidth={2} />
                {/* æ‹/ç´°åˆ† */}
                {[...Array(ticksPerBar)].map((__, t) => {
                  if (t === 0) return null;
                  const x = pagePadding + xOf(bar, t);
                  const isBeat = t % division === 0;
                  if (showBeat && isBeat) {
                    return <line key={`beat-${bar}-${t}`} x1={x} x2={x} y1={pagePadding + topPadding - 8} y2={pagePadding + topPadding + (stringCount - 1) * stringGap + 8} stroke="#cfd4da" strokeWidth={1} />;
                  } else if (showSubdivision) {
                    return <line key={`sub-${bar}-${t}`} x1={x} x2={x} y1={pagePadding + topPadding - 4} y2={pagePadding + topPadding + (stringCount - 1) * stringGap + 4} stroke="#edf2f4" strokeWidth={1} />;
                  }
                  return null;
                })}
                {/* å°ç¯€ç•ªå· */}
                {showBarNumber && (
                  <text x={barX + 6} y={pagePadding + topPadding - 10} fontSize={12} fill="#6c757d" fontFamily="ui-sans-serif, system-ui">{bar + 1}</text>
                )}
              </g>
            );
          })}
          {/* å³ç«¯ã®çµ‚æ­¢ç·š */}
          <line x1={pagePadding + leftPadding + bars * barPx}
                x2={pagePadding + leftPadding + bars * barPx}
                y1={pagePadding + topPadding - 14}
                y2={pagePadding + topPadding + (stringCount - 1) * stringGap + 14}
                stroke="#adb5bd" strokeWidth={2} />

          {/* å¼¦ */}
          {[...Array(6)].map((_, s) => (
            <line key={`str-${s}`}
                  x1={pagePadding + leftPadding}
                  x2={pagePadding + leftPadding + bars * barPx}
                  y1={yForString(s)} y2={yForString(s)} stroke="#212529" strokeWidth={1.2} />
          ))}

          {/* ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆã“ã®è¡Œã ã‘ï¼‰ */}
          {items.filter(it => it.rowIndex === rowIndex).map(it => {
            const x = pagePadding + xOf(it.bar, it.tick);
            const y = yForString(it.stringIndex);
            const sel = isSelected(it.id);
            const label = it.kind === "mute" ? "Ã—" : String(it.fret ?? 0);
            return (
              <g
                key={it.id}
                onPointerDown={(e) => {
                  if (mode === "select") {
                    e.stopPropagation();
                    e.preventDefault();
                    beginDragFromItem(e as any, it, rowIndex);
                  }
                }}
                onDoubleClick={(e) => {
                  e.stopPropagation();
                  beginInlineEdit(it.id);
                }}
              >
                {sel && (<rect x={x - 11} y={y - 11} width={22} height={16} rx={4} fill="white" stroke="#4c6ef5" />)}
                {drawText(x, y, label)}
              </g>
            );
          })}

          {/* ãƒ‰ãƒ©ãƒƒã‚°ä¸­ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆã“ã®è¡Œã ã‘ï¼‰ */}
          {(() => {
            const ghost = computeDragPreview();
            return ghost.filter(it => it.rowIndex === rowIndex).map(it => {
              const x = pagePadding + xOf(it.bar, it.tick);
              const y = yForString(it.stringIndex);
              const label = it.kind === "mute" ? "Ã—" : String(it.fret ?? 0);
              const key = `ghost-${it.id}-${it.bar}-${it.tick}-${it.stringIndex}`;
              return (
                <g key={key} opacity={0.8} pointerEvents="none">
                  <rect x={x - 11} y={y - 11} width={22} height={16} rx={4} fill="white" stroke="#94a3b8" strokeDasharray="3 2" />
                  {drawText(x, y, label, "#94a3b8")}
                </g>
              );
            });
          })()}

          {/* ãƒ›ãƒãƒ¼ã‚¬ã‚¤ãƒ‰ï¼ˆæç”»ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿ï¼‰ */}
          {(mode === "draw" && hoverPos) && (() => {
            const x = pagePadding + xOf(hoverPos.bar, hoverPos.tick);
            const y = yForString(hoverPos.stringIndex);
            return (
              <g>
                <circle cx={x} cy={y} r={2} fill="#4c6ef5" />
                {drawText(x, y, drawToken?.kind === "mute" ? "Ã—" : String(drawToken?.value ?? 0), "#868e96")}
              </g>
            );
          })()}

          {/* å·¦ç«¯ã®ç¸¦ç·š */}
          <line x1={pagePadding + leftPadding} x2={pagePadding + leftPadding}
                y1={pagePadding + topPadding} y2={pagePadding + topPadding + (stringCount - 1) * stringGap}
                stroke="#212529" strokeWidth={2} />

          {/* ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚¨ãƒ‡ã‚£ã‚¿ï¼ˆã“ã®è¡Œã«å±ã™ã‚‹é¸æŠã®ã¿ï¼‰ */}
          {(() => {
            if (!editingId) return null;
            const n = items.find(x => x.id === editingId);
            if (!n || n.rowIndex !== rowIndex) return null;
            const pos = itemXYRow(n);
            return (
              <foreignObject x={pos.x - 14} y={pos.y - 14} width={32} height={24}>
                <input
                  autoFocus
                  type="text"
                  value={editValue}
                  onChange={(e) => setEditValue(e.target.value.replace(/[^0-9]/g, ""))}
                  onBlur={commitInlineEdit}
                  onKeyDown={(e) => {
                    if (e.key === "Enter") commitInlineEdit();
                    if (e.key === "Escape") { setEditingId(null); setSelectedIds([]); }
                  }}
                  style={{ width: "100%", height: "100%", textAlign: "center", fontWeight: 700, border: "1px solid #4c6ef5", borderRadius: 6, outline: "none" }}
                />
              </foreignObject>
            );
          })()}

          {/* çŸ©å½¢é¸æŠã®å¯è¦–åŒ– */}
          {marquee && (() => { const r = normRect(marquee); return (
            <rect x={r.x} y={r.y} width={r.w} height={r.h} fill="rgba(76,110,245,0.08)" stroke="#4c6ef5" strokeDasharray="4 3" />
          );})()}
        </svg>
      </div>
    );

    return (
      <div className="row-wrap">
        <LeftFixed />
        <RightScroll />
      </div>
    );
  };

  // ã‚¢ãƒ³ãƒã‚¦ãƒ³ãƒˆæ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ä¸­çµ‚äº†ã®ä¿é™ºï¼‰
  useEffect(() => {
    return () => {
      try { cleanupDragSideEffects(); } catch {}
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <div
      className="min-h-screen bg-neutral-50 text-neutral-800 p-6 select-none"
      onPointerDown={(e) => { if (e.target === e.currentTarget) { cancelEditingAndSelection(); } }}
    >
      <div className="max-w-[1200px] mx-auto space-y-4">
        {/* å›ºå®šãƒ„ãƒ¼ãƒ«ãƒãƒ¼ */}
        <div className="toolbar-fixed" onPointerDown={(e) => { if (e.target === e.currentTarget) { cancelEditingAndSelection(); } }}>
          <div className="toolbar-inner toolbar-layout">
            <div className="pitch-row">{pitchText}</div>

            {/* å·¦ä¸Šï¼šãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿ */}
            <div className="mode-row">
              <button type="button" className="btn btn-toggle btn-sm" data-active={mode === 'select'} aria-pressed={mode === 'select'} title="é¸æŠãƒ¢ãƒ¼ãƒ‰" onClick={() => { cancelEditingAndSelection(); setMode('select'); }}>é¸æŠ</button>
              <button type="button" className="btn btn-toggle btn-sm" data-active={mode === 'draw'} aria-pressed={mode === 'draw'} title="æç”»ãƒ¢ãƒ¼ãƒ‰" onClick={() => { cancelEditingAndSelection(); setMode('draw'); }}>æç”»</button>
              {mode === 'draw' && (
                <>
                  <span className="sep-vert" />
                  <span className="text-xs text-neutral-600">ç¾åœ¨ã®æç”»: {drawToken?.kind === 'mute' ? 'Ã—' : (drawToken?.value ?? 0)}</span>
                  <button className="btn btn-sm" title="ãƒŸãƒ¥ãƒ¼ãƒˆï¼ˆÃ—ï¼‰" onClick={() => setDrawToken({ kind: 'mute' })}>Ã—</button>
                </>
              )}
            </div>

            {/* å·¦ä¸Šã®å°‘ã—ä¸‹ï¼šReset / Undo / Redo */}
            <div className="history-row">
              <button className="btn btn-icon" title="å…¨æ¶ˆã—ï¼ˆResetï¼‰" onClick={() => { if (!canReset) return; pushHistory(); setItems([]); setSelectedIds([]); setEditingId(null); }} disabled={!canReset} aria-disabled={!canReset}>Reset</button>
              <button className="btn btn-icon" title="ä¸€ã¤æˆ»ã‚‹ï¼ˆUndoï¼‰" onClick={undo} disabled={!canUndo} aria-disabled={!canUndo}>â†©ï¸</button>
              <button className="btn btn-icon" title="ä¸€ã¤é€²ã‚€ï¼ˆRedoï¼‰" onClick={redo} disabled={!canRedo} aria-disabled={!canRedo}>â†ªï¸</button>
            </div>

            {/* å·¦ä¸‹ï¼šè¡¨ç¤ºãƒˆã‚°ãƒ« */}
            <div className="display-row">
              <label className="chk"><input type="checkbox" checked={showBarNumber} onChange={(e) => setShowBarNumber(e.target.checked)} />å°ç¯€ç•ªå·</label>
              <label className="chk"><input type="checkbox" checked={showBeat} onChange={(e) => setShowBeat(e.target.checked)} />æ‹ã‚°ãƒªãƒƒãƒ‰</label>
              <label className="chk"><input type="checkbox" checked={showSubdivision} onChange={(e) => setShowSubdivision(e.target.checked)} />ç´°åˆ†ç·š</label>
              {selectedIds.length > 0 && (
                <button className="btn btn-sm" title="é¸æŠã‚’å‰Šé™¤" onClick={() => { pushHistory(); setItems((arr) => arr.filter(i => !selectedIds.includes(i.id))); setSelectedIds([]); }}>å‰Šé™¤</button>
              )}
            </div>

            {/* å³ä¸Šï¼šæ›¸ãå‡ºã—ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§é–‹ããƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼‰ */}
            <div className="export-row">
              <div className="export-menu" ref={exportMenuRef}>
                <button
                  type="button"
                  className="btn btn-sm export-trigger"
                  aria-haspopup="menu"
                  aria-expanded={exportOpen}
                  onClick={() => setExportOpen(v => !v)}
                  onKeyDown={(e) => { if (e.key === "Enter" || e.key === " ") setExportOpen(v => !v); }}
                  title="ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå½¢å¼ã‚’é¸æŠ"
                >
                  ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ â–¾
                </button>

                <div
                  className="export-dropdown"
                  role="menu"
                  aria-label="ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå½¢å¼"
                  data-open={exportOpen ? "true" : "false"}
                >
                  <button
                    type="button"
                    className="export-item"
                    role="menuitem"
                    onClick={() => { setExportOpen(false); downloadSVG(); }}
                  >
                    SVGã§æ›¸ãå‡ºã™
                  </button>
                  <button
                    type="button"
                    className="export-item"
                    role="menuitem"
                    onClick={() => { setExportOpen(false); downloadPNG(); }}
                  >
                    PNGã§æ›¸ãå‡ºã™
                  </button>
                </div>
              </div>
            </div>

            {/* å³ä¸‹ï¼šå°ç¯€/æ‹/åˆ†å‰²/æ®µæ•°ã®è¨­å®š */}
            <div className="settings-row">
              <span className="label">å°ç¯€:</span>
              <input type="number" className="input w-20" value={bars} min={1} max={128}
                     onChange={(e) => { cancelEditingAndSelection(); setBars(clamp(parseInt(e.target.value || '1'), 1, 128)); }} />
              <span className="label">æ‹/å°ç¯€:</span>
              <input type="number" className="input w-20" value={beatsPerBar} min={1} max={12}
                     onChange={(e) => { cancelEditingAndSelection(); setBeatsPerBar(clamp(parseInt(e.target.value || '4'), 1, 12)); }} />
              <span className="label">åˆ†å‰²:</span>
              <select className="input" value={division} onChange={(e) => { cancelEditingAndSelection(); setDivision(parseInt(e.target.value, 10)); }}>
                <option value={1}>1</option>
                <option value={2}>2</option>
                <option value={3}>3</option>
                <option value={4}>4 (16åˆ†)</option>
                <option value={6}>6</option>
                <option value={8}>8</option>
              </select>
              <span className="label">1æ®µã®å°ç¯€æ•°:</span>
              <select className="input" value={perSystemBars} onChange={(e) => { cancelEditingAndSelection(); setPerSystemBars(parseInt(e.target.value, 10)); }}>
                {[2,3,4,6,8].map(n => <option key={n} value={n}>{n}</option>)}
              </select>
            </div>
          </div>
        </div>

        {/* å›ºå®šãƒ„ãƒ¼ãƒ«ãƒãƒ¼åˆ†ã®ã‚¹ãƒšãƒ¼ã‚µ */}
        <div className="toolbar-spacer" />

        {/* è¡Œãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼ˆå…¨è¡Œã‚’åŒã˜æ§‹é€ ã«çµ±ä¸€ï¼‰ */}
        <div className="sheet-wrap">
          {Array.from({ length: rowCount }).map((_, i) => (
            <div key={`row-${i}`} className="sheet-row">
              {renderRow(i)}
            </div>
          ))}
        </div>
      </div>

      {/* ç”»é¢ä¸‹ã®å›ºå®šãƒãƒ¼ */}
      <div className="bottom-fixed">
        <button className="btn btn-sm" title="è¡Œã‚’è¿½åŠ " onClick={() => setRowCount(n => Math.min(n + 1, 16))}>ï¼‹ è¡Œã‚’è¿½åŠ </button>
        <button className="btn btn-sm" data-active={linkScroll} title={linkScroll ? "ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åŒæœŸ: ONï¼ˆã‚¯ãƒªãƒƒã‚¯ã§è§£é™¤ï¼‰" : "ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åŒæœŸ: OFFï¼ˆã‚¯ãƒªãƒƒã‚¯ã§æœ‰åŠ¹ï¼‰"} onClick={() => setLinkScroll(v => !v)}>
          {linkScroll ? "ğŸ”— Chain" : "â›“ï¸ Unchain"}
        </button>
      </div>

      <style jsx global>{`
        .input { @apply border border-neutral-300 rounded-xl px-2 py-1 focus:outline-none focus:ring-2 focus:ring-neutral-400; }
        .btn { @apply px-3 py-1.5 rounded-xl border border-neutral-300; }
        .btn-toggle { @apply bg-white text-neutral-800 hover:bg-neutral-100; }
        .btn-toggle[data-active="true"] { border-color: #3b82f6 !important; box-shadow: 0 0 0 2px rgba(59,130,246,0.9) !important; }
        .btn-toggle[data-active="true"]:hover { background-color: #fff !important; }
        .chk { @apply inline-flex items-center gap-2 text-sm text-neutral-700; }

        .toolbar-fixed { position: fixed; top: 0; left: 0; right: 0; z-index: 100; background: #ffffff !important; border-bottom: 1px solid #e5e7eb; }
        .toolbar-inner { max-width: 1200px; margin-left: auto; margin-right: auto; padding: 0.75rem; display: block; }
        .toolbar-inner.toolbar-layout { position: relative; height: 105px; }
        .toolbar-spacer { height: 150px; }

        :root, html, body { color-scheme: light !important; }
        html, body { background-color: #fafafa !important; color: #111 !important; }
        button, input, select, textarea { background-color: #ffffff !important; color: #111 !important; border-color: #d4d4d8 !important; appearance: none; -webkit-appearance: none; }
        .input { background-color: #ffffff !important; color: #111 !important; border-color: #d4d4d8 !important; }
        .btn   { background-color: #ffffff !important; color: #111 !important; border-color: #d4d4d8 !important; }

        input:-webkit-autofill { -webkit-text-fill-color: #111 !important; transition: background-color 9999s ease-out 0s; }
        input:-webkit-autofill, input:-webkit-autofill:focus, select:-webkit-autofill, textarea:-webkit-autofill { -webkit-text-fill-color: #111 !important; box-shadow: 0 0 0px 1000px #ffffff inset !important; background-clip: padding-box !important; }
        ::placeholder { color: #6b7280 !important; opacity: 1 !important; }
        svg, svg * { -webkit-user-select: none !important; user-select: none !important; }
        svg ::selection { background: transparent; }

        .mode-row { position: absolute; top: 8px; left: 12px; display: inline-flex; gap: 6px; align-items: center; }
        .history-row { position: absolute; top: 55px; left: 12px; display: inline-flex; gap: 6px; align-items: center; }
        .display-row { position: absolute; bottom: 8px; left: 12px; display: inline-flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .export-row { position: absolute; top: 8px; right: 12px; display: inline-flex; gap: 8px; align-items: center; }
        .settings-row { position: absolute; bottom: 8px; right: 12px; display: inline-flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        .settings-row .label { font-size: 12px; color: #52525b; }

        .pitch-row { position: absolute; top: 8px; left: 50%; transform: translateX(-50%); font-weight: 800; font-size: 40px; letter-spacing: 0.5px; color: #111; pointer-events: none; user-select: none; }

        /* ===== æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«è¡Œãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ ===== */
        .row-wrap{display:flex;position:relative}
        .sheet-row  { margin-bottom: 12px; }

        :root { --row-stick-top: 150px; }
        
        .row-left-fixed{
          position: relative;
          left: auto;
          top: auto;
          z-index: 5;
          flex: 0 0 calc(24px + 72px);
          background:#fff;
          border-right:1px solid #e5e7eb;
          pointer-events:none;
        }

        .row-right-scroll{overflow-x:auto;overflow-y:hidden;flex:1 1 auto;-webkit-overflow-scrolling:touch}
        .row-left-line{position:absolute;left:0;transform:translateY(-50%);width:calc(24px + 72px - 8px);text-align:right;padding-right:6px}
        .row-left-name { font-family: ui-monospace, Menlo, monospace; font-size: 12px; color: #495057; }

        /* ===== ã‚«ãƒ¼ã‚½ãƒ«åˆ¶å¾¡ï¼ˆç‚¹æ»…é˜²æ­¢ï¼‰ ===== */
        .row-svg { display:block; cursor: grab; }
        .row-svg * { cursor: inherit !important; } /* ãƒ†ã‚­ã‚¹ãƒˆ/rectä¸Šã§ã‚‚åŒã˜ã‚«ãƒ¼ã‚½ãƒ«ã«å›ºå®š */
        .row-svg.dragging { cursor: grabbing !important; }
        html[data-dragging="1"] * { cursor: grabbing !important; } /* ãƒšãƒ¼ã‚¸å…¨ä½“ã§å›ºå®š */

        .bottom-fixed { position: fixed; left: 0; right: 0; bottom: 0; height: 44px; display: flex; gap: 8px; align-items: center; justify-content: center; background: rgba(255,255,255,0.96); border-top: 1px solid #e5e7eb; z-index: 80; }
        .btn[data-active="true"] { border-color: #3b82f6 !important; box-shadow: 0 0 0 2px rgba(59,130,246,0.25) !important; }

        /* ===== Export dropdown ===== */
        .export-menu { position: relative; display: inline-block; }
        .export-trigger { /* ãƒœã‚¿ãƒ³è¦‹ãŸç›®ã¯æ—¢å­˜ .btn .btn-sm ã‚’æµç”¨ */ }

        .export-dropdown {
          display: none;
          position: absolute;
          right: 0;
          top: calc(100% + 6px);
          min-width: 160px;
          background: #fff;
          border: 1px solid #e5e7eb;
          border-radius: 10px;
          padding: 6px;
          box-shadow: 0 12px 20px rgba(0,0,0,0.08);
          z-index: 200;
        }
        .export-dropdown[data-open="true"] { display: block; }

        .export-item {
          width: 100%;
          text-align: left;
          padding: 8px 10px;
          border-radius: 8px;
          border: 0;
          background: transparent;
          font-size: 14px;
          line-height: 1.2;
          cursor: pointer;
        }
        .export-item:hover { background: #f3f4f6; }

        /* ===== ä½™ç™½å¹²æ¸‰ã®ç„¡åŠ¹åŒ–ï¼ˆå®‰å…¨å´ï¼‰ ===== */
        .toolbar-fixed + .toolbar-spacer { margin-top: 0 !important; }
        .toolbar-spacer + .sheet-wrap { margin-top: 0 !important; }
        .sheet-wrap { display: flow-root; }
      `}</style>
    </div>
  );
}
